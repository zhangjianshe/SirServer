# .github/workflows/release.yml

# IMPORTANT: Ensure ALL indentation uses EXACTLY 2 spaces.
# Do NOT use tabs, as they will cause YAML parsing errors.

name: Go Release with Signing (Windows & Linux)

# This workflow runs when a new tag is pushed (e.g., v1.0.0)
on:
  push:
    tags:
      - 'v*.*.*' # Trigger on tags like v1.0.0, v1.2.3, etc.

jobs:
  # Job for Linux builds (no specific app signing usually required for Go binaries on Linux)
  build-linux:
    runs-on: ubuntu-latest
    outputs:
      linux_archives: ${{ steps.archive.outputs.archive_paths }} # To pass to create-release job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Build Linux (AMD64)
        env:
          GOOS: linux
          GOARCH: amd64
        run: |
          APP_NAME="SirServer"
          OUTPUT_FILE="${APP_NAME}-${GOOS}-${GOARCH}"
          echo "Building for $GOOS/$GOARCH as $OUTPUT_FILE"
          go build -o "$OUTPUT_FILE" ./main.go
          echo "BUILT_BINARY_LINUX_AMD64=$OUTPUT_FILE" >> $GITHUB_ENV # Store for packaging

      - name: Build Linux (ARM64)
        env:
          GOOS: linux
          GOARCH: arm64
        run: |
          APP_NAME="SirServer"
          OUTPUT_FILE="${APP_NAME}-${GOOS}-${GOARCH}"
          echo "Building for $GOOS/$GOARCH as $OUTPUT_FILE"
          go build -o "$OUTPUT_FILE" ./main.go
          echo "BUILT_BINARY_LINUX_ARM64=$OUTPUT_FILE" >> $GITHUB_ENV # Store for packaging

      - name: Package Linux binaries
        id: archive
        run: |
          APP_NAME="SirServer"
          ARCHIVE_AMD64="${APP_NAME}-linux-amd64.tar.gz"
          ARCHIVE_ARM64="${APP_NAME}-linux-arm64.tar.gz"

          # Create tar.gz archives
          tar -czvf "$ARCHIVE_AMD64" "${{ env.BUILT_BINARY_LINUX_AMD64 }}"
          tar -czvf "$ARCHIVE_ARM64" "${{ env.BUILT_BINARY_LINUX_ARM64 }}"

          # Output paths for the create-release job
          echo "archive_paths=$ARCHIVE_AMD64 $ARCHIVE_ARM64" >> $GITHUB_OUTPUT

  # Job for Windows builds and Authenticode signing
  build-windows:
    runs-on: windows-latest # Crucial: Use a Windows runner for signtool.exe
    outputs:
      windows_archive: ${{ steps.archive.outputs.archive_path }} # To pass to create-release job
      # Output the thumbprint so the next step can use it
      certificate_thumbprint: ${{ steps.import_cert.outputs.thumbprint }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Build Windows (AMD64)
        env:
          GOOS: windows
          GOARCH: amd64
        run: |
          $env:APP_NAME="SirServer"
          $env:EXT=".exe"
          $env:OUTPUT_FILE="${env:APP_NAME}-${env:GOOS}-${env:GOARCH}${env:EXT}"
          Write-Host "Building for $env:GOOS/$env:GOARCH as $env:OUTPUT_FILE"
          go build -o "$env:OUTPUT_FILE" ./main.go
          echo "BUILT_BINARY_WINDOWS_AMD64=$env:OUTPUT_FILE" | Out-File -FilePath $env:GITHUB_ENV -Append

        shell: powershell

      - name: Decode and Install Certificate (Windows)
        id: import_cert # Added an ID to this step
        run: |
          # Referencing the specified secret names
          $base64Cert = "${{ secrets.APP_SIGNING_CERTIFICATE_BASE64 }}" 
          $certPassword = "${{ secrets.CERTIFICATE_PASSWORD }}" 
          
          # Add error handling for empty password
          if ([string]::IsNullOrEmpty($certPassword)) {
              Write-Error "Certificate password secret (CERTIFICATE_PASSWORD) is empty. Please check your GitHub Secrets."
              exit 1
          }
          
          # Check if the PFX file exists after decoding
          if (-not (Test-Path "certificate.pfx")) {
              $certBytes = [System.Convert]::FromBase64String($base64Cert)
              [System.IO.File]::WriteAllBytes("certificate.pfx", $certBytes)
              Write-Host "certificate.pfx created successfully."
          } else {
              Write-Host "certificate.pfx already exists."
          }

          Write-Host "Attempting to import certificate.pfx..."
          try {
              # Import the certificate and capture the imported object
              $importedCert = Import-PfxCertificate -FilePath "certificate.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password (ConvertTo-SecureString -String $certPassword -AsPlainText -Force) -ErrorAction Stop
              Write-Host "Certificate imported successfully."
          
              # Output the thumbprint for the next step
              echo "thumbprint=$($importedCert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          } catch {
              Write-Error "Failed to import certificate: $($_.Exception.Message)"
              exit 1
          }
          
          Remove-Item certificate.pfx # Clean up the PFX file from disk immediately after import

          # IMPORTANT DEBUGGING STEP: List all certificates in the store and their subjects
          Write-Host "Listing certificates in Cert:\CurrentUser\My (for verification):"
          Get-ChildItem Cert:\CurrentUser\My | ForEach-Object {
              Write-Host "  Subject: $($_.Subject)"
              Write-Host "  Thumbprint: $($_.Thumbprint)"
              Write-Host "  FriendlyName: $($_.FriendlyName)"
              Write-Host "  Issuer: $($_.Issuer)"
              Write-Host "  NotAfter: $($_.NotAfter)"
              Write-Host "---"
          }

        shell: powershell

      - name: Sign Windows Executable
        run: |
          $signtoolPath = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\" -Filter "signtool.exe" -Recurse | Select-Object -ExpandProperty FullName -First 1
          if (-not $signtoolPath) {
              Write-Error "Signtool.exe not found. Ensure Windows SDK Signing Tools are installed."
              exit 1
          }

          # Retrieve the thumbprint from the previous step's output (most reliable method)
          $thumbprint = "${{ steps.import_cert.outputs.thumbprint }}"
          
          if ([string]::IsNullOrEmpty($thumbprint)) {
              Write-Error "Certificate thumbprint was not obtained from the previous step. Cannot sign."
              exit 1
          }

          # Find the certificate by its Thumbprint
          $cert = Get-ChildItem Cert:\CurrentUser\My | Where-Object {$_.Thumbprint -eq $thumbprint}
          
          if (-not $cert) {
              Write-Error "Certificate with thumbprint '$thumbprint' not found in store. This should not happen if previous step succeeded."
              exit 1
          }
          if ($cert.Count -gt 1) {
              Write-Warning "Multiple certificates found matching the thumbprint. This is unusual; using the first one."
              $cert = $cert | Select-Object -First 1
          }
          Write-Host "Found certificate with Subject: $($cert.Subject) and Thumbprint: $thumbprint"

          $binaryToSign = "${{ env.BUILT_BINARY_WINDOWS_AMD64 }}"
          Write-Host "Signing $binaryToSign with thumbprint $thumbprint"
          
          # Sign the application using the certificate from the store by thumbprint
          # Using a timestamp server is highly recommended for long-term validity
          & "$signtoolPath" sign /s My /sha1 $thumbprint /t http://timestamp.digicert.com /fd sha256 /v $binaryToSign
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Signtool failed with exit code $LASTEXITCODE"
              exit 1
          }
          Write-Host "Successfully signed $binaryToSign"

        shell: powershell

      - name: Package Windows binary
        id: archive
        run: |
          $env:APP_NAME="SirServer"
          $env:ARCHIVE_NAME="${env:APP_NAME}-windows-amd64.zip"
          $binaryToArchive = "${{ env.BUILT_BINARY_WINDOWS_AMD64 }}" # Use the env variable for the built binary

          # Use Compress-Archive instead of zip
          # -Path specifies the file(s) to compress
          # -DestinationPath specifies the name of the output zip file
          # -Force overwrites if the file already exists
          Compress-Archive -Path $binaryToArchive -DestinationPath $env:ARCHIVE_NAME -Force
          Write-Host "Created archive: $env:ARCHIVE_NAME"

          echo "archive_path=$env:ARCHIVE_NAME" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: powershell

  # Job to create the GitHub Release and upload all artifacts
  create-release:
    runs-on: ubuntu-latest
    # This job now only depends on the Linux and Windows build jobs
    needs: [build-linux, build-windows]
    permissions:
      contents: write # Required to create and upload release assets
      packages: write

    steps:
      - name: Get tag name
        id: get_tag
        run: echo "TAG_NAME=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Delete existing release if it exists
        uses: actions/github-script@v7
        id: delete_release
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = context.ref.replace('refs/tags/', '');
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });

              const existingRelease = releases.find(release => release.tag_name === tag);

              if (existingRelease) {
                console.log(`Found existing release for tag ${tag} with ID ${existingRelease.id}. Deleting...`);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: existingRelease.id,
                });
                console.log(`Release ${tag} deleted successfully. Waiting for 5 seconds to ensure propagation...`);
                await new Promise(resolve => setTimeout(resolve, 5000)); // Wait for 5 seconds
              } else {
                console.log(`No existing release found for tag ${tag}.`);
              }
            } catch (error) {
              console.error(`Error checking/deleting release: ${error.message}`);
              # Do not fail the workflow here, just log the error
            }

      - name: Create and Upload Release Assets
        uses: softprops/action-gh-release@v2
        with:
          # Use the outputs from the remaining build jobs as files to upload
          files: |
            ${{ needs.build-linux.outputs.linux_archives }}
            ${{ needs.build-windows.outputs.windows_archive }}
          draft: false
          prerelease: false
          name: Release ${{ steps.get_tag.outputs.TAG_NAME }}
          tag_name: ${{ steps.get_tag.outputs.TAG_NAME }}
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GitHub automatically provides this token